{"meta":{"title":"COSProject 技术笔记","subtitle":"对新的技术有追求，关注后端动态；喜欢 coding，热爱开源。","description":"COSProject,cosproject,java,JDK,spring,springboot,源码分析","author":"binaryCodeSequence","url":"https://bytestruct.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-02-20T08:25:30.313Z","updated":"2021-02-20T08:25:30.313Z","comments":false,"path":"/404.html","permalink":"https://bytestruct.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-02-20T08:25:30.313Z","updated":"2021-02-20T08:25:30.313Z","comments":false,"path":"about/index.html","permalink":"https://bytestruct.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2021-02-20T08:25:30.313Z","updated":"2021-02-20T08:25:30.313Z","comments":false,"path":"categories/index.html","permalink":"https://bytestruct.com/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-02-20T08:25:30.313Z","updated":"2021-02-20T08:25:30.313Z","comments":false,"path":"repository/index.html","permalink":"https://bytestruct.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-02-20T08:25:30.314Z","updated":"2021-02-20T08:25:30.314Z","comments":false,"path":"tags/index.html","permalink":"https://bytestruct.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java 内存模型","slug":"java-memory-model","date":"2021-03-16T02:46:05.000Z","updated":"2021-03-21T13:46:29.360Z","comments":true,"path":"2021/03/16/java-memory-model/","link":"","permalink":"https://bytestruct.com/2021/03/16/java-memory-model/","excerpt":"","text":"Java 虚拟机内部使用 Java 内存模型将内存划分为两个逻辑单元，线程栈和堆。 在 Java 虚拟机中，每一个线程都有属于自己的线程栈，而线程栈会存储被调用的方法和这些方法的局部变量(基本类型和引用类型)，假设有下面这样一个方法： 123456public void method() &#123; // 基本类型 int i = 0; // 引用类型 Test test = new Test();&#125; 当两个独立的线程调用同一个方法时(不管是不是同一个对象的)，每个线程都会在各自的线程栈中创建局部变量的副本，对于基本数据类型(boolean、byte、short、char、int、long、float、double) 都是直接创建副本到线程栈中，而对于引用类型( Byte、Integer、Long 等) 它的引用(就是变量名test) 是存储在线程栈中，对象本身(就是Test这个对象) 是存储在堆中的(就是说对象都是存储在堆上)；并且每个线程只能访问自己的线程栈(就是说对其它线程不可见)。注意：这里说的是每个方法，方法 A 调用方法 B 时，当前线程栈会保存这两个被调用的方法以及这些方法的局部变量。 但是，对于对象的成员变量不管是基本类型还是引用类型，这些成员变量和对象本身(包括静态类)都是存储在堆上的；只要一个线程有对该对象的引用，那么这个线程就能访问堆上的对象，并且也能够访问该对象的成员变量，但每个线程都有自己的局部变量副本。 个人理解是：方法中使用了成员变量，那么就会创建这成员变量的副本存储到线程栈中。 下面这张图说明了上述几点： 有两个线程，它们分别有一组局部变量，其中局部变量 Local Variable 2 都指向堆上的同一个共享对象(Object 3)；这两个线程各自对同一个对象有一个不同的引用，它们的引用都是局部变量，因此会存储在每个线程的线程栈中；并且都可以通过 Object 3 中的成员变量的引用，使这两个线程可以访问 Object 2 和 Object 4。 上图中还展示了一个局部变量，它们分别指向堆上的两个不同对象(Object 1 和 Object 5)，而不是同一个对象；所以，一个线程不能访问 Object 1，另一个线程不能访问 Object 5。 下面的代码描述了上述内存图： 1234567891011121314151617181920212223242526272829303132333435363738public class MyRunnable implements Runnable() &#123; public void run() &#123; methodOne(); &#125; public void methodOne() &#123; int localVariable1 = 45; MySharedObject localVariable2 = MySharedObject.sharedInstance; //... do more with local variables. methodTwo(); &#125; public void methodTwo() &#123; Integer localVariable1 = new Integer(99); //... do more with local variable. &#125;&#125;public class MySharedObject &#123; //static variable pointing to instance of MySharedObject public static final MySharedObject sharedInstance = new MySharedObject(); //member variables pointing to two objects on the heap public Integer object2 = new Integer(22); public Integer object4 = new Integer(44); public long member1 = 12345; public long member2 = 67890;&#125; 每个执行 methodOne() 的线程都会在各自的线程栈上创建自己的 localVariable1 和 localVariable2 的副本；localVariable1 副本之间将完全分离，只活在每个线程的线程栈上；一个线程不能看到另一个线程对 localVariable1 的做了什么改变。 localVariable2 之间也是完全分离的，但是这两个不同副本最终都指向静态变量所引用的对象(堆上的同一个对象)。静态变量只有一个副本，这个副本存储在堆上；因此，localVariable2 的两个副本最终都指向静态变量指向的 MySharedObject。MySharedObject 实例也存储在堆上。它对应于上图中的 Object 3。 注意 MySharedObject 类也包含了四个成员变量，这些成员变量和对象一起存储在堆上，其中两个成员变量指向另外两个 Integer 对象，这些 Integer 对象对应上图中的 Object 2 和 Object 4。 在 methodTwo() 方法中创建了一个名为 localVariable1 的局部变量，这个局部变量是对 Integer 对象的引用，localVariable1 引用将在每个执行 methodTwo() 的线程中存储一个副本；但是由于该方法每次执行时都会创建一个新的 Integer 对象，所以 localVariable1 引用指向一个新的 Integer 实例，对应上图中的 Object 1 和 Object 5。 硬件内存架构现代硬件内存架构与 Java 内部的内存模型有一定的区别。了解硬件内存架构也是很重要的，要了解 Java 内存模型是如何与之合作的。 现在的计算机中往往有 2 个或更多的 CPU，这些 CPU 都有多个核心，每个 CPU 在任何时候都能够运行一个线程或同时运行多个线程；这意味着，如果你的 Java 应用程序是多线程的，那么每个 CPU 所执行的线程，可能在你的 Java 应用程序中同时(并发) 运行。 每个 CPU 都包含一组寄存器，这些寄存器基本上是 CPU 内的内存。CPU 在这些寄存器上执行操作的速度比在主内存中的变量上执行操作的速度快得多。这是因为 CPU 访问这些寄存器的速度比访问主内存的速度快得多。 计算机中都一个或多个内存(RAM) 也就是主内存区，所有的 CPU 都可以访问主内存，主内存区域通常比 CPU 的缓存存储器大得多。 每个CPU还可能有一个CPU高速缓存存储器层。事实上，大多数现代CPU都有一定规模的高速缓存存储器层。CPU访问其缓存存储器的速度比主存储器快得多，但通常没有访问其内部寄存器的速度快。所以，CPU的高速缓存存储器的速度介于内部寄存器和主存储器的速度之间。有些CPU可能有多个缓存层（Level 1和Level 2），但这并不是那么重要，要了解Java内存模型如何与内存交互。重要的是要知道CPU可以有某种形式的缓存内存层。 通常情况下，当一个 CPU 需要访问主内存时，它将把主内存的一部分数据读到它的 CPU 缓存中。它甚至可能将缓存的一部分读入其内部寄存器中，然后对其进行操作。当 CPU 需要将结果写回主内存时，它会将其内部寄存器中的值冲到缓存中，并在某一时刻将该值冲回主内存。 当CPU需要在缓存存储器中存储其他东西时，缓存存储器中存储的值通常会被冲回主存储器。CPU缓存一次可以有数据写入部分内存，一次可以有部分内存被刷新。它不必每次更新时都要读/写全部缓存。通常，缓存是以较小的内存块更新的，称为 “缓存线”。一条或多条缓存线可以被读入缓存内存，一条或多条缓存线可以再次被刷新回主内存。 参考资料Java Memory Model What is the Java memory model? Java堆和栈看这篇就够","categories":[{"name":"Java VM","slug":"Java-VM","permalink":"https://bytestruct.com/categories/Java-VM/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://bytestruct.com/tags/Java/"}]},{"title":"happens-before 关系","slug":"happens-before","date":"2021-02-28T09:05:51.000Z","updated":"2021-03-16T02:53:31.419Z","comments":true,"path":"2021/02/28/happens-before/","link":"","permalink":"https://bytestruct.com/2021/02/28/happens-before/","excerpt":"","text":"如果使用 Java 开发多线程应用程序，那么需要了解如何在 Java 程序中处理共享变量。共享变量就是某个变量被多个线程使用，就像 Synchronization and Locks#Thread-Interference 文章中的实例变量c，当然静态字段和数组元素都是共享变量；除此之外，可以在线程之间共享的内存称为共享内存或堆内存。 而处理共享变量，一个重要的因素就是 happens-before 关系，但是了解它之前需要先了解可见性。 局部变量、形式化方法参数和异常处理程序参数永远不会在线程之间共享，也不会受到内存模型的影响。 Visibility(可见性)现在的 CPU 架构都是多核心，每个核心都能够处理多个执行线程；并且对于每个核心，都存在多个级别的缓存，这些缓存定期与主存协调，如下图所示： 针对共享变量的写入操作，会因为每个核心缓存共享变量的值，而导致写入主内存时发生延迟，另一个线程读取到的变量值是个旧值。 考虑下面这种情况：两个线程对同一个变量执行读和写操作。 12345678910111213141516public class StopThread &#123; private static boolean stopRequested; public static void main(String[] args) throws InterruptedException &#123; Thread backgroundThread = new Thread(new Runnable() &#123; public void run() &#123; int i = 0; while (!stopRequested) i++; &#125; &#125;); backgroundThread.start(); TimeUnit.SECONDS.sleep(1); stopRequested = true; &#125; &#125; 在backgroundThread线程中一直递增i的值，直到stopRequested变为true。 理想情况下，程序应该运行 1 秒，在stopRequested变为true后，backgroundThread应该结束，并且整个程序也会终止。但是如果你在多核计算机上运行上述程序，你会发现程序一直在执行而没有被终止；这是因为两个线程运行在两个不同的核心上，stopRequested将被分别加载到对应的核心缓存中，所以主线程修改stopRequested变量值后，不能保证立即对backgroundThread可见，它会无限循环或变量同步到主内存后才会停止。 也就是说第二个线程观察不到第一个线程的操作结果，所以这个操作是不可见的。 Happens-before relationship Java 中对 Happens-before 定义为：如果一个动作 Happens-before 另一个动作，那么第一个是可见的，并且会排序在第二个之前排序。也就是说，happens-before 可以排序两个动作。 为了更好的理解这句话，首先了解以下重排序(指令重排)；为了提高程序性能 Java VM 和 CPU，在不影响执行结果的前提下都会对代码进行重新排序。假设有下面这样一段代码： 12345a = b + cd = a + el = m + ny = x + z 重排序后，可能会变成下面这个样子，由于前三行没有任何关联(关联指的是变量之间相互依赖，例如第六行代码依赖第一行代码，所以他们之间是有关联的)，CPU 有可能会并行执行前三行，从而提高程序性能。 123456a = b + cl = m + ny = x + zd = a + e 使用图形展示了重排序和指令执行的情况： 现在来解释 Happens-before 的定义，“一个动作 Happens-before 另一个动作” 这里说的只是两个动作，也就是说没有相互关联的两个动作之间也会存在 Happens-before 关系。 所以第一行和第三行代码之间是 Happens-before 关系，第一行和第四行之间也是 Happens-before 关系；在上面这四行代码中会存在很多 Happens-before 关系，这里就不一一列举了。 但是要注意，如果这些代码都是由同一个线程(串行)运行，那么无论怎么重排序，程序的执行结果都不会改变；但是重排序并不保证多线程的执行结果。 假设有两个线程分别执行下面的代码： Thread 1 Thread 2 B = 1; A = 2; r2 = A; r1 = B; A和B都是共享变量，默认值都为零。由于 Thread1 中的两条指令没有相互关联，所以 Java VM 和 CPU 会对它们进行任意排序；同样的 Thread2 中的两条指令也可以任意排序。 下面是重排序后指令执行的第一种情况： 12341: B = 1;3: A = 2;2: r2 = A;4: r1 = B; 两个线程在交替执行，r2和r1的值都是默认值零；这是因为 3 和 2 之间并不存在 Happens-before 关系，同样的 1 和 4 直接也不存在。可能你还有一个疑问，就是为啥有时候会出现r2的值为 2，r1的值为 1 的情况呢？ 这是一个有趣的情况，这种情况会违背你的直觉；这是因为 Java 内存模型允许读操作可以观察到执行顺序中稍后发生的写操作。 12341: r2 = A;3: r1 = B;2: B = 1;4: A = 2; r2赋值时会读取A的值，但是同时又观察到了A的写操作，所以r2的值为 2，r1也是同样的道理。值得注意的是，这种情况并不属于 Happens-before 关系。 保证了可见性，但是并不保证原子性。原子操作包含了可见性。 参考资料17.4.5. Happens-before Order Handling Java Memory Consistency with happens-before relationship Java - Understanding Happens-before relationship Java Happens Before Guarantee 第七章 重排序与happens-before","categories":[{"name":"Java 并发","slug":"Java-并发","permalink":"https://bytestruct.com/categories/Java-%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://bytestruct.com/tags/Java/"}]},{"title":"Synchronization and Locks","slug":"synchronization-and-locks","date":"2021-02-24T12:44:25.000Z","updated":"2021-02-28T09:40:09.432Z","comments":true,"path":"2021/02/24/synchronization-and-locks/","link":"","permalink":"https://bytestruct.com/2021/02/24/synchronization-and-locks/","excerpt":"","text":"如果你刚接触到并发和多线程，那么可以先看一下下面这两篇文章： 进程和线程 【番外篇】并发&amp;并行 本篇笔记只会说一些基础知识和使用，并不涉及到源码分析。 线程之间的通讯非常有效的方式是使用共享对象，但是可能会导致两种错误：thread interference 和 memory consistency errors。为了防止这些错误可以使用synchronization。 然而，synchronization又引入线程竞争，当两个或多个线程试图同时访问同一资源时就会出现，并导致Java运行时更缓慢地执行一个或多个线程，甚至暂停其执行。 Thread Interference123456789101112131415class Counter &#123; private int c = 0; public void increment() &#123; c++; &#125; public void decrement() &#123; c--; &#125; public int value() &#123; return c; &#125;&#125; 假设，线程A调用increment()方法使变量c自加1，线程线程B调用decrement()方法使变量c自减1。 但是，表达式c++可以分解为三个步骤，c--和c++一样： 获取c的值。 将这个值增加1。 将加1后的值存储到c中。 当这两个线程使用的都是同一个Counter对象并对c进行操作时就会产生交错，这种情况就是线程干扰，并会导致数据出错。 下面列出了交错执行时的一种顺序： 线程A：获取c的值。 线程B：获取c的值。 线程A：将这个值增加1。 线程B：将这个值递减1。 线程A：将结果存储在c中；c现在是1。 线程B：将结果存储在c中；c现在为-1。 但是这种交错顺序不是唯一的，没有固定顺序，甚至有时候会出现操作执行正确的情况。 简单理解就是：多个线程访问相同数据，操作数据的时候产生了交错；这种情况就是线程干扰。 Memory Consistency Errors线程干扰指的是操作数据的时候，而内存一致性错误指的是访问数据的时候。 假设，线程A调用increment()方法使变量c自加1，线程线程B调用value()方法获取变量c的值。 线程B很有可能获取的值是0，这是因为线程A修改了值，不能保证对线程B是立即可见的。 除了使用同步解决这个问题外，还可以使用Thread#join方法。 同步方法Java 编程语言提供了两种基本的同步用法：同步方法和同步代码块。 要使方法同步，只需将synchronized关键字添加到其声明中： 123456789101112131415public class SynchronizedCounter &#123; private int c = 0; public synchronized void increment() &#123; c++; &#125; public synchronized void decrement() &#123; c--; &#125; public synchronized int value() &#123; return c; &#125;&#125; 如果将SynchronizedCounter代替Counter，则使这些方法同步具有两个效果： 首先，当一个线程正在执行某个同步方法时，会挂起所有调用了这个同步方法的其它线程，直到第一个线程执行完这个方法。这样就解决了代码的交错执行。 其次，当同步方法退出时，后续调用相同对象的同步方法时，它会自动建立一个happens-before关系。这保证了对象状态的更改对所有线程都是可见的。 注意，不能将synchronized关键字与构造方法一起使用。同步构造方法没有任何意义，因为只有在创建对象时，创建对象的线程才可以访问它，其它情况下只是使用该对象的方法。 同步方法提供了一种防止线程干扰和内存一致性错误的简单策略：如果一个对象对一个以上线程可见，则对该对象变量的所有读取或写入均通过synchronized方法完成。 同步语句创建同步代码的另一种方法是使用同步语句。与同步方法不同，同步语句必须指定提供内部锁的对象： 1234567public void addName(String name) &#123; synchronized(this) &#123; lastName = name; nameCount++; &#125; nameList.add(name);&#125; 在本例中，addName方法需要同步对lastName和nameCount做修改，但是要尽量避免在同步语句中调用其他对象的方法；因为这有可能会导致死锁。 如果想要在一个静态方法中使用同步语句，则可以使用： 12345public static void performStaticSyncTask() &#123; synchronized(SynchronisedBlocks.class) &#123; setStaticCount(getStaticCount() + 1); &#125;&#125; 重进入在 Java 中，内部锁本质上都是可重入的。重入就是为了方式线程自身阻塞。 ReentrantLock(可重入锁)ReentrantLock直接实现了Lock接口，和synchronized关键字一样都有线程同步机制；但是它们两个的实现方法不一样，并且前者更强大。 个人感觉ReentrantLock类是最接近Lock接口的实现。 如果需要它的高级功能，可以使用，否则还是建议使用synchronized。因为这两个的性能一样，synchronized可以自动释放锁，还有就是ReentrantLock实现类没有自适应旋转。 扩展点 Lock 接口java.util.concurrent.locks.Lock接口的用作类似于synchronized关键字，它们两个都有线程同步的机制。但是实现方式不一样，并且和synchronized相比，Lock更加灵活，主要区别如下： 非块结构：synchronized强制所有获取和释放锁在一个结构块中，而lock()和unlock()可以在不同的结构块中调用。可以将结构快认为是个代码块。 顺序保证：synchronized并不会保证让这些等待线程的顺序执行，因为是随机一个线程来获取锁并执行，也就是说它没有公平性。但是要注意：公平锁不能保证线程调度的公平性，因为线程调度是操作系统负责。 可超时获取锁：没有超时获取锁的功能。Lock接口可以通过tryLock(long timeout，TimeUnit timeUnit)指定超时时间。 可中断获取锁：假设线程A 中调用了lock.lockInterruptibly()方法获取锁，当某个线程调用了线程A.interrupt()方法时，则lockInterruptibly()方法会立即抛出InterruptedException异常。interrupt()方法就是Thread#interrupt方法。 除此之外，Lock接口可以通过newCondition()创建Condition实例。 值得注意的是：该接口提供了三种形式的锁获取可中断、不可中断和定时。 讨论1. 为什么synchronized关键字作用在方法上，就不需要提供内部锁对象？ 无论是静态方法还是实例方法，都可以使用synchronized关键字。当作用在方法上时，它就会自动获取内部锁对象。 静态方法：当前类的名称.class 实例方法：this 参考资料Synchronization Java 8 Concurrency Tutorial: Synchronization and Locks Guide to the Synchronized Keyword in Java Java Concurrency - Lock Interface Synchronized Vs ReentrantLock in Java Choosing Between Synchronized and ReentrantLock ReentrantLock可中断锁 扩展阅读","categories":[{"name":"Java 并发","slug":"Java-并发","permalink":"https://bytestruct.com/categories/Java-%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://bytestruct.com/tags/Java/"}]},{"title":"【番外篇】并发&并行","slug":"concurrency-and-parallel","date":"2021-02-20T15:47:19.000Z","updated":"2021-02-28T09:39:51.550Z","comments":true,"path":"2021/02/20/concurrency-and-parallel/","link":"","permalink":"https://bytestruct.com/2021/02/20/concurrency-and-parallel/","excerpt":"","text":"在学习多线程的时候，总是会提到同步、异步、并发、并行等术语，这些术语对于初学者来说晦涩难懂，而且网上的其它文章对此解释的含糊不清；还有就是好多复制粘贴的文章，甚至这些文章连错别字都一样。 同步同步的英文是：Synchronization，根据维基百科中对 Synchronization 的解释：同步是指两种不同但相关概念的其中一个：进程同步和数据同步。 在生产者－消费者关系中，消费者会一直等待生产者的数据。 分叉和联接：当主任务想快速处理某些数据时，可以分成 N 个子任务；而主任务又会等待所有子任务处理完成，然后主任务再进行其它业务逻辑处理。 独家资源使用或者说是排他资源使用：当有多个线程需要访问同一个资源时，其他线程只能等待。 上面说的这三种是同步的主要需求，下面详细说一下线程或进程同步。 线程或进程同步对于同步来说，我个人认为线程同步和进程同步是一样的。出现这两种说法应该是历史原因，因为操作系统之前的最小调度单位是进程，而随着发展现在变成了线程。所以我觉得只需要知道线程同步就可以了。 假设有三个线程，即1、2 和 3。这三个线程正在同时执行，并且它们需要访问同一个公共资源，如下图： 为了防止访问共享资源时产生冲突。因此，当线程 1 和 2 都尝试访问该资源时，必须同一时间只有一个线程能访问。 如果将其分配给线程 1，则线程 2 需要等待，直到线程 1 释放该资源。 其实可以简单的认为：在多线程环境下，同一时间只有一个线程能访问资源(其它线程会等待)，就可以认为是同步。 在 Java 中要想实现这种情况，可以使用 synchronized 关键字。 异步在维基百科中也有对 Asynchrony (computer programming) 的解释，通俗的讲就是：当发生了一个事件的时候，这个事件的处理方式和程序的流程是没有关系的，也就是说程序不会一直等待这个事件处理完。 例如，当管理员 A 查询所有用户的时候，管理员 B 同时又能对某个用户信息做修改，而不是要等到管理员 A 操作结束后才能修改用户信息。 还有就是在同步中提到的子任务、线程，这些都是异步。 其实可以简单的认为：只要某一个事件在另一个线程中执行，这就是异步。 并发假设计算机只有一个 CPU，则应用程序可能无法完全同时完成多个任务，但是在应用程序中一次可能要完成多项任务。为了同时完成多个任务，CPU 在执行期间会在不同任务之间进行切换。 类似下面这张图一会执行 Task1 一会执行 Task2，但是并不会一起执行。 可能你看到这张图的时候会惊呼：这不就是多线程的执行方式吗？ 是的，这就是多线程的执行方式；注意，这里说的是执行方式。多线程并不等于 CPU，多线程指的是同一个程序中有多个执行的线程，这些线程由不同的 CPU 内核处理。 另外值得注意的是：这里不考虑 CPU 超线程技术，所以上图中的两个任务永远不会同一时间开始执行，Task1 或 Task2 必定有一个先执行。 通过上面说的这些，我们可以得出三个重点： 单核 CPU 两个(多个)任务永远不会同一时间开始执行 同时完成多个任务 所以个人理解，并发就是 CPU 执行多任务的一种方式，这些任务交替执行并且大概在相同的时间内完成，但是 CPU 并不是同时执行这些任务。 也可以简化为：多个任务交替执行，但是这些任务并不是同时开始执行并且大概在相同时间内完成。 下图展示了多线程和 CPU 之间的关系： 这里的 CPU 你可以认为是多核 CPU 中某个核心的一个线程或者就是一个单核的 CPU。这里说 “某个核心的一个线程”，是因为 超线程 技术；如果这里只是说某个 CPU 核心，则该核心使用了超线程技术，就有可能会导致两个任务同时开始。可以简单的理解超线程技术：使某个物理内核实现并行计算。超线程技术我也不是很理解，就知道能并行计算。 并行执行先说一下，并发和并行是不一样的。 并行执行是指，计算机有多个 CPU 或一个 CPU 有多个核心，同时执行多个任务。但是，并行执行不等于并行性。 并行执行如下图所示： 并行并发执行根据 CPU 上分布的不同任务，得出的结论就是：在同一 CPU 上执行的任务是并发执行的，而在不同 CPU 上执行的线程是并行执行的。 并行性假设现在有一个比较复杂的任务，我们把这个复杂的任务拆分成 4 个子任务，然后将这 4 个子任务分别由 4 个不同的线程执行，并且这些线程分别运行在 2 个不同的 CPU 上。 这意味着，这些子任务的一部分是并发执行的(在同一 CPU 上执行的)，而另一部分是并行执行的(在不同 CPU 上执行的)。 如果这4个子任务是由在各自的CPU上运行的4个线程执行的(总共4个CPU)，那么任务执行应该是完全并行的。 然而，将一个任务分解为与可用cpu数量完全相同的子任务并不总是容易的 通常，更容易的做法是将一个任务分解为一些自然适合手头任务的子任务，然后让线程调度程序负责将线程分配到可用的cpu中。 并行性和并行并发执行看起来很相似，但是术语并行性是指应用程序将某个任务分解为较小的子任务，这些子任务可以并行处理。 我个人认为，并行性是在应用程序中的说法，并发和并行是在 CPU 中的说法。 参考资料Synchronization (computer science) Asynchrony (computer programming) Concurrency vs. Parallelism Concurrency != Parallelism Concurrency and parallelism are two different things","categories":[{"name":"Java 并发","slug":"Java-并发","permalink":"https://bytestruct.com/categories/Java-%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://bytestruct.com/tags/Java/"}]},{"title":"Java 线程基础","slug":"java-thread-base","date":"2021-02-20T13:40:01.000Z","updated":"2021-02-28T09:39:57.165Z","comments":true,"path":"2021/02/20/java-thread-base/","link":"","permalink":"https://bytestruct.com/2021/02/20/java-thread-base/","excerpt":"","text":"Java 中线程的生命周期和线程的状态可以理解为：在其生命周期中，线程会经历各种状态。 类似于下面这张图是最常见的： 使用 new Thread 创建出来的线程就是 NEW 状态，这个时候线程并没有启动；当调用 start() 方法时，线程状态就会变成 RUNNABLE 状态。 当 t1 获得锁，t2 会等待 t1 释放锁，这个时候 t2 线程的状态就是 BLOCKED 阻塞状态。 当调用了线程的 Object#wait()、Thread#join() 或 LockSupport#park() 方法时，就会变成 WAITTING 状态；如果调用的是带有超时参数的就会变成 TIMED_WAITTING 状态。 线程执行结束就是 TERMINATED 状态。 在 Java 中线程一共就分为 6 种状态并且可以通过 state() 方法查看线程状态。 创建线程123456Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;Thread run&quot;); &#125;&#125;); 上面是 Java 创建一个线程的例子，下面代码展示了这个线程具体是怎么创建的，Thread 构造方法最终都会调用 init 方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals) &#123; /* 每一个线程必须有一个名字，默认的线程名称是：Thread- 加上线程ID。 */ if (name == null) &#123; throw new NullPointerException(&quot;name cannot be null&quot;); &#125; this.name = name; /* 假设在线程 A 中，调用了 new Thread 创建了线程 B。 这里获取线程 A 是为了，将线程 A 的一些配置传递给线程 B。*/ Thread parent = currentThread(); SecurityManager security = System.getSecurityManager(); /* 每一个线程必须有一个线程组，如果没有指定则会先获取安全管理器中的线程组，否则再回去父级(线程A)线程组。 */ if (g == null) &#123; if (security != null) &#123; g = security.getThreadGroup(); &#125; if (g == null) &#123; g = parent.getThreadGroup(); &#125; &#125; /* 判断当前线程(线程A) 有没有操作线程组的权限，如果没有就会抛出 SecurityException。 因为 Thread#start() 方法会操作线程组。*/ g.checkAccess(); if (security != null) &#123; /* 主要用来判断子类有没有重写 getContextClassLoader 和 setContextClassLoader 方法，如果重写了则返回 true。*/ if (isCCLOverridden(getClass())) &#123; /* 既然重写了那么就判断一下有没有重写权限(enableContextClassLoaderOverride)，如果没有则抛出 SecurityException。*/ security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION); &#125; &#125; /* 将线程组中的 未启动线程 变量加 1。*/ g.addUnstarted(); this.group = g; this.daemon = parent.isDaemon(); this.priority = parent.getPriority(); /* 如果重写了就调用子类的 getContextClassLoader() 方法，否则就直接获取父类的 ClassLoader 就可以了。*/ if (security == null || isCCLOverridden(parent.getClass())) this.contextClassLoader = parent.getContextClassLoader(); else this.contextClassLoader = parent.contextClassLoader; /* 我也不清楚为什么要获取这个。*/ this.inheritedAccessControlContext = acc != null ? acc : AccessController.getContext(); this.target = target; /* 设置线程优先级。*/ setPriority(priority); /* 继承父级的 ThreadLocal.ThreadLocalMap。 当然自己的线程数据可以放到 ThreadLocal.ThreadLocalMap threadLocals 中。*/ if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); this.stackSize = stackSize; tid = nextThreadID();&#125; init 方法中的相关方法currentThread() 是一个本地方法，下面是 JVM 的源码。 1 这里先挖坑。 拓展知识点 Runnable 接口Runnable 这个接口可以理解成线程的任务接口，它里面只有一个无参的 run 方法，线程启动后就会执行这个方法中的代码。 讨论1. Thread 为什么要实现 Runnable 接口？ 当线程启动后就会执行 Runnable#run 方法，这里实现该接口是为了，当没有传递接口实例的时候，也可以保证线程正常运行。 只不过这里的运行只是线程空转一次。 2. 为什么要传递线程配置？ 3. 当线程状态是 NEW 的时候，操作系统有没有启动线程？ 首先 Java 线程就是操作系统线程， 4. 为什么要弃用 stop()、suspend()、resume() 方法？ 当调用 Thread#stop() 方法时，就会将线程持有的锁立即释放掉，其它线程所看到的状态就会不一样。 5. 为什么 wait 在 Object 中？ 参考资料Life Cycle of a Thread in Java","categories":[{"name":"Java 并发","slug":"Java-并发","permalink":"https://bytestruct.com/categories/Java-%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://bytestruct.com/tags/Java/"}]},{"title":"进程和线程","slug":"processes-and-threads","date":"2021-02-20T08:59:58.000Z","updated":"2021-02-28T09:40:01.649Z","comments":true,"path":"2021/02/20/processes-and-threads/","link":"","permalink":"https://bytestruct.com/2021/02/20/processes-and-threads/","excerpt":"","text":"很多同学都听说过，现代操作系统比如 Mac OS X，UNIX，Linux，Windows 等，都是支持 “多任务” 的操作系统。 什么叫 “多任务” 呢？简单地说，就是操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听 MP3，一边在用 Word 赶作业，这就是多任务。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。 现在，多核CPU已经非常普及了，但是，即使过去的单核CPU，也可以执行多任务。由于CPU执行代码都是顺序执行的，那么，单核CPU是怎么执行多任务的呢？ 答案就是操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。 真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。 进程对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。 也就是说，一个程序就是一个进程。 线程比如 Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。 由于每个进程至少要干一件事，所以，一个进程至少有一个线程。当然，像 Word 这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核 CPU 才可能实现。 也就是说，可以把进程理解成一个容器，里面可能有很多个线程帮我们做不同的事情。 参考资料进程和线程","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://bytestruct.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://bytestruct.com/tags/Java/"}]}],"categories":[{"name":"Java VM","slug":"Java-VM","permalink":"https://bytestruct.com/categories/Java-VM/"},{"name":"Java 并发","slug":"Java-并发","permalink":"https://bytestruct.com/categories/Java-%E5%B9%B6%E5%8F%91/"},{"name":"操作系统","slug":"操作系统","permalink":"https://bytestruct.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://bytestruct.com/tags/Java/"}]}